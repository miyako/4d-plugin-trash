/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-Trash.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Trash
 #	author : miyako
 #	2020/03/13
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-Trash.h"

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
			// --- Trash
            
			case 1 :
				Trash_item(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

#if VERSIONMAC
void ob_set_s(PA_ObjectRef obj, const wchar_t *_key, NSString *_value) {
    
    C_TEXT t;
    t.setUTF16String(_value);
    
    CUTF16String u16;
    t.copyUTF16String(&u16);
    
    ob_set_a(obj, _key, &u16);
}
#endif

#if VERSIONWIN

 BOOL generate_uuid(std::wstring &uuid_string) {
     
     UUID uuid;
     RPC_WSTR flagPtr;
     if(UuidCreate(&uuid) == RPC_S_OK) {
         if(UuidToString(&uuid, &flagPtr) == RPC_S_OK) {
             uuid_string = std::wstring((const wchar_t *)flagPtr, wcslen((const wchar_t *)flagPtr));
             RpcStringFree(&flagPtr);
             return true;
         }
     }
     return false;
 }

unsigned __stdcall trash_item(void *p) {

    BOOL success = FALSE;
	int res = 0;

    DWORD path_size = 0;
    DWORD uuid_size = 0;
    
    std::wstring path;
    std::wstring uuid;
    
	DWORD len = (sizeof(DWORD) * 2);

    HANDLE fmIn = CreateFileMapping(
                                    INVALID_HANDLE_VALUE,
                                    NULL,
                                    PAGE_READWRITE,
                                    0, len,
                                    L"TRASH_PARAM_IN");

    if (fmIn)
    {
        LPVOID bufIn = MapViewOfFile(fmIn, FILE_MAP_READ, 0, 0, len);
        if (bufIn)
        {
            unsigned char *p = (unsigned char *)bufIn;
            try
            {
                CopyMemory(&path_size, p, sizeof(DWORD));
                p += sizeof(DWORD);
                CopyMemory(&uuid_size, p, sizeof(DWORD));
                p += sizeof(DWORD);

                std::vector<unsigned char>_path(path_size);
                std::vector<unsigned char>_uuid(uuid_size);
                
                if(path_size) {
                    CopyMemory(&_path[0], p, path_size);
                    p += path_size;
                    path = std::wstring((const wchar_t *)&_path[0], path_size / sizeof(wchar_t));
                    
                    success = TRUE;
                }
                
                if(uuid_size) {
                    CopyMemory(&_uuid[0], p, uuid_size);
                    p += uuid_size;
                    uuid = std::wstring((const wchar_t *)&_uuid[0], uuid_size / sizeof(wchar_t));
                }

            }
            catch (...)
            {
                
            }
            
            UnmapViewOfFile(bufIn);
        }
        
        
        CloseHandle(fmIn);
    }

    HANDLE pEvent = OpenEvent(EVENT_ALL_ACCESS,
                              FALSE, /* processes created by this process do not inherit this handle */
                              uuid.c_str());
    if (pEvent)
    {
        SetEvent(pEvent);
        CloseHandle(pEvent);
    }
    
    if(success){

		std::vector<wchar_t>_path(path.length() + 2);
		memcpy(&_path[0], path.c_str(), path.length() * sizeof(wchar_t));

        SHFILEOPSTRUCT fileOp;
        memset(&fileOp, 0x0, sizeof(SHFILEOPSTRUCT));
        
        fileOp.hwnd = NULL;
        fileOp.wFunc = FO_DELETE;

        fileOp.fFlags = FOF_ALLOWUNDO | FOF_NO_UI;

        fileOp.pFrom = (PCZZWSTR)&_path.at(0);
        fileOp.pTo = L"\0\0";
		
        res = ::SHFileOperation(&fileOp);
        
    }

    _endthreadex(0);
    return 0;
}

HANDLE createFmIn(
                  std::wstring& path,
                  std::wstring& uuid) {
    
    DWORD len = (sizeof(DWORD) * 2);
    
    DWORD path_size = path.length() * sizeof(wchar_t);
    DWORD uuid_size = uuid.length() * sizeof(wchar_t);
    
    len += path_size;
    len += uuid_size;
    
    BOOL success = FALSE;
    
    HANDLE fmIn = CreateFileMapping(
                                    INVALID_HANDLE_VALUE,
                                    NULL,
                                    PAGE_READWRITE,
                                    0,
                                    len,
                                    L"TRASH_PARAM_IN");
    if(fmIn)
    {
        LPVOID bufIn = MapViewOfFile(fmIn,
                                     FILE_MAP_WRITE,
                                     0,
                                     0, len);
        if(bufIn)
        {
            try
            {
                unsigned char *p = (unsigned char *)bufIn;
                
                //{meta}
                CopyMemory(p, &path_size, sizeof(DWORD));
                p += sizeof(DWORD);
                CopyMemory(p, &uuid_size, sizeof(DWORD));
                p += sizeof(DWORD);
                
                //{data}
                CopyMemory(p, path.c_str(), path_size);
                p += path_size;
                CopyMemory(p, uuid.c_str(), uuid_size);
                
                success = TRUE;
            }
            catch(...)
            {
                
            }
            UnmapViewOfFile(bufIn);
        }
        if(!success)
        {
            CloseHandle(fmIn);
            return 0;
        }
    }
    
    return fmIn;
}

#endif

void Trash_item(PA_PluginParameters params) {

    PA_ObjectRef returnValue = PA_CreateObject();
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    trash_operation_mode_t trash_operation_mode = (trash_operation_mode_t)PA_GetLongParameter(params, 2);

    C_TEXT Param1;
    Param1.fromParamAtIndex(pParams, 1);
    
#if VERSIONMAC
    
    NSURL *url = Param1.copyUrl();
    if(url) {
        
        NSURL *resultingItemURL = nil;
        NSError *error = nil;
        
        BOOL success = false;
        
        switch (trash_operation_mode) {
                
            case trash_operation_synchronous:
                
                success = [[NSFileManager defaultManager]trashItemAtURL:url
                                                       resultingItemURL:&resultingItemURL
                                                                  error:&error];
                ob_set_b(returnValue, L"success", success);
                if(success){
                    
                    if(resultingItemURL){
                        NSString *path = (NSString *)CFURLCopyFileSystemPath((CFURLRef)resultingItemURL,
                                                                             kCFURLPOSIXPathStyle);
                        if(path){
                            ob_set_s(returnValue, L"path", path);
                            [path release];
                        }
                    }
                }else{
                    if(error) {
                        ob_set_n(returnValue, L"error", [error code]);
                        ob_set_s(returnValue, L"errorString", [error description]);
                    }
                    
                }
                break;
                
            default:
                
                [[NSWorkspace sharedWorkspace]recycleURLs:@[url] completionHandler:nil];
                break;
        }
        [url release];
    }
#else
    
    CUTF16String u16;
    Param1.copyUTF16String(&u16);
        
	std::wstring path = std::wstring((const wchar_t *)u16.c_str(), u16.length());

    switch (trash_operation_mode) {
        
    case trash_operation_synchronous:
        {

		std::vector<wchar_t>_path(path.length() + 2);
		memcpy(&_path[0], path.c_str(), path.length() * sizeof(wchar_t));

		SHFILEOPSTRUCT fileOp;
		memset(&fileOp, 0x0, sizeof(SHFILEOPSTRUCT));

		fileOp.hwnd = NULL;
		fileOp.wFunc = FO_DELETE;

		fileOp.fFlags = FOF_ALLOWUNDO | FOF_NO_UI;

		fileOp.pFrom = (PCZZWSTR)&_path.at(0);
		fileOp.pTo = L"\0\0";

		int res = ::SHFileOperation(&fileOp);
            
            ob_set_b(returnValue, L"success", (res == 0));
            
            if(res != 0){
                ob_set_n(returnValue, L"error", res);
            }else{
                ob_set_b(returnValue, L"success", !fileOp.fAnyOperationsAborted);
            }
        }
            break;
            
            default:
        {
				std::wstring uuid;

            if(generate_uuid(uuid)){
                HANDLE pEvent = CreateEvent(NULL, /* the handle cannot be inherited by child processes */
                                            TRUE, /* creates a manual-reset event object */
                                            FALSE, /* initial state of the event object */
                                            uuid.c_str());
                if(pEvent){
                    
                    HANDLE fmIn = createFmIn(
                                             path,
                                             uuid);
                    
                    if(fmIn){
                        
                        HANDLE h = (HANDLE)_beginthreadex(NULL /* security: handle not inherited */,
                        0 /* stack size:default */,
                        trash_item,
                        NULL /* arguments */,
                        0 /* init flags:execute immediately */,
                        NULL /* thread id */);
                        
                        if(h)
                        {
                            BOOL exit = FALSE;
                            do {
                                switch (WaitForSingleObject(pEvent, 100))
                                {
                                    case WAIT_ABANDONED:
                                    case WAIT_FAILED:
                                        exit = TRUE;
                                        break;
                                    case WAIT_TIMEOUT:
                                        PA_YieldAbsolute();
                                        break;
                                    case WAIT_OBJECT_0:
                                        ResetEvent(pEvent);
                                        exit = TRUE;
                                        break;
                                }
                                
                            } while (!exit);
                            
                            CloseHandle(h);
                        }//h
                        
                        CloseHandle(fmIn);
                    }
                    CloseHandle(pEvent);
                }
            }
        }
            break;
    }
#endif
    
    PA_ReturnObject(params, returnValue);
}

